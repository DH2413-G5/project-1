using System.Collections;
using System.Collections.Generic;
using Oculus.Interaction.Input;
using Oculus.Interaction.PoseDetection;
using UnityEngine;


public class Swimmer_update : MonoBehaviour
{
    private Rigidbody _rigidbody;
    // Helps calculate time between strokes.
    private float _cooldownTimer;
    private Vector3 handVelocity = Vector3.zero;

    [SerializeField]
    private IHand Hand;

    [SerializeField]
    private IJointDeltaProvider JointDeltaProvider;

    private float _lastUpdateTime;
    private void Awake() {
        // Caching the rigidbody.
        _rigidbody = GetComponent<Rigidbody>();
        // Turn off gravity for a floating/swimming effect.
        _rigidbody.useGravity = false;
        // Prevent rotations of the rigidbody to combat motion sickness.
        _rigidbody.constraints = RigidbodyConstraints.FreezeRotation;
    }


    private void FixedUpdate() {
        /*var leftHandVelocity = leftControllerVelocity.action.ReadValue<Vector3>();*/
        /*var rightHandVelocity = rightControllerVelocity.action.ReadValue<Vector3>();*/
        LogWristVelocity();
        
        // Check if player should swim forward
        _cooldownTimer += Time.fixedDeltaTime;

        /*if (_cooldownTimer > minTimeBetweenStrokes) {
            // Calculate the total velocity generated by both hands.
            var leftHandVelocity = leftControllerVelocity.action.ReadValue<Vector3>();
            Debug.Log("Hand Velocity: " + leftHandVelocity);
            var rightHandVelocity = rightControllerVelocity.action.ReadValue<Vector3>();
            Vector3 localVelocity = leftHandVelocity + rightHandVelocity;
            // Inverting velocity: moving forward by pulling backwards.
            localVelocity *= -1;

            // Using .sqrMagnitude for performance. To get the .magnitude, Unity has to do a sqrt operation. 
            if (localVelocity.sqrMagnitude > minForce * minForce) {
                // Calculating the world velocity and apply it to the rigidbody
                Vector3 worldVelocity = trackingReference.TransformDirection(localVelocity);
                _rigidbody.AddForce(worldVelocity * swimForce, ForceMode.Acceleration);
                // Resetting cooldown for strokes
                _cooldownTimer = 0f;
            }
        }

        // Apply water drag force if player is moving
        if (_rigidbody.velocity.sqrMagnitude > 0.01f) {
            _rigidbody.AddForce(-_rigidbody.velocity * dragForce, ForceMode.Acceleration);
        }*/
    }
    
    private void LogWristVelocity()
    {
        float deltaTime = Time.time - _lastUpdateTime;

        // 找到与手腕有关的速度
        if (Hand.GetRootPose(out Pose rootPose) &&
            Hand.GetJointPose(HandJointId.HandWristRoot, out Pose curPose) &&
            JointDeltaProvider.GetPositionDelta(HandJointId.HandWristRoot, out Vector3 worldDeltaDirection))
        {
            // 由于我们只是打印速度，不需要目标方向。但如果你想要沿某个特定方向的速度，你可以使用类似的方法来获取它。
            float velocity = worldDeltaDirection.magnitude / deltaTime;

            // 打印速度
            Debug.Log($"HandWristRoot velocity: {velocity} units/sec");
        }

        _lastUpdateTime = Time.time;
    }

}